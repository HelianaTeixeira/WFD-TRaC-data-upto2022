---
title: "R Notebook"
output:
  word_document: default
  html_notebook: default
---

Description:
adapted to CW and TW from FW Geoff Phillips
Date: 11 April 2023
File name for script: BLM_boundaries_TraC_SS.Rmd

##  Background

This workbook shows an example of determining supporting element boundary values using a binary linear model, where the threshold probability used to calculate the boundary is identified using a confusion  matrix.  

To simplify the process a user function *modBLM* is used. This function runs the model, creates a series of confusion matrices and outputs possible boundary values.  Details of this are explained below.  The approach is 

1.  Setup, load libraries and functions
2.  Get the data
3.  Select the sub-set (e.g. type) to be modeled
4.  Run the model
5.  Generate figures to illustrate the results

The process from 3-5 can be repeated with results added to a data frame that can subsequently be used to tabulate results.

All of the functions used are in file *Function_BLM_EQR.R* which  needs to be loaded


##  Setup

First we load the libraries needed and run the user functions in R script *Functions_BLM_EQR.R*
```{r, include=TRUE}

#Load the required libraries (some of these may not be needed)
suppressPackageStartupMessages(library(tidyverse))
suppressPackageStartupMessages(library(here))
suppressPackageStartupMessages(library(rms))
suppressPackageStartupMessages(library(modEvA))
suppressPackageStartupMessages(library(openxlsx)) 
suppressPackageStartupMessages(library(grid))# for multiple plot single legend
suppressPackageStartupMessages(library(gridExtra))
suppressPackageStartupMessages(library(patchwork))#for grid layout of plots
#suppressPackageStartupMessages(library(lmtest))# for Breusch-Pagan Test for heteroscedascity
suppressPackageStartupMessages(library(ggpubr))
suppressPackageStartupMessages(library(kableExtra))
suppressPackageStartupMessages(library(knitr))

source("Functions_BLM_EQR.R")
```


##  Identify the SE to be modelled

The functions are intended to be sufficiently generic to allow any variable name to be used for the SE of interest

Add the name of the SE variable as in the data set used, for example *SecchiDepth_m*  

Add the text used for axis labels in plot functions  

Add the name of the binary dependent variable, the biological class (1 = Good, 0 =Not Good). The variable name *BinClass* can be generated in this script from the NEQR. However, if classification data are used, for example the WFD data sets then a different name can be used  

Set the number of decimals for rounding boundary values in plots

The first line of the following chunk lists the measures that are most useful and thus the ones included in table outputs.  (additional measures can  be specified, see *out$optEach$measure* for full list)


```{r, include=TRUE}
measure_used <- c("default","kappa","TKitMM","Com0.2","OmisComm","Com0.1","Sens0.9")# useful measures
SE <- "SuspendedMatter_mgL.1"    # name of data column containing SE in data file        
xlabel="turbidity (mg/L)"
BiotaClass <- "BinClass" # name of data column containing binary class
dec <- 2
```

##  Get the data

Load the data, and select the EQR variable used to establish the biota class.  The following chunk will need to be modified to match the data used.

The final data needs to include the 2 key variables
The concentration of the SE (variable name specified above in SE)
The binary class of the biota (default name is *BinClass*, but other variable names can be used)

In the example I get lake SoE data, filter for macrophyte records and use the variable *resultNormalisedEQRValue*  to convert to *BinClass*.  I also convert the EQR variable name to *NEQR* as this is used in my standard plot functions

```{r getData, include=TRUE}
# Get the data
datIC <- read.csv(file = here("Databases","IC_selected_datasets.csv"),sep = ",") #EDIT file name / path

# Select the data for SE Transparency (SS)
datIC.SS <- datIC %>% 
  select (BQE,Country,WaterCategory,GIG,ICtype,Date_BQE,EQR,EQS,SuspendedMatter_gL.1)%>% #EDIT: SE variable name
  filter(!is.na(SuspendedMatter_gL.1)) %>%
  #mutate(BinClass=ifelse(NEQR>=0.6,1,0)) #use this line instead when normalised EQR
  rename(BinClass=EQS)%>%
  rename(NEQR=EQR) #EDIT optional: but needs change also in functions be aware!, here kept NEQR even if not normalised in this IC dataset

# Create 2 data frames that can be used to hold the results from different subsets of the data
optEach_all <- data.frame()
BLMsum_all <- data.frame()
```


###  Select subset of data and run the model

On the assumption that we want type specific boundary values I select this in the following chunk. In this example for CW type BC4.  I save this as a separate data object for convenience and as a record.
It is important to remove all SE missing values.


Then run the model function *modBLM*. This runs the model, generates a confusion matrix using the *modEva* package and collects useful outputs from the package.  Set plt=FALSE to suppress graphical output from  modEva (useful for additional information)

Output is returned as a list object to *out* which needs to be split into separate data frames

1.  *mod.pred*    the predicted values for the model used for plotting and to determine standard errors
2.  *allMeasures* data frame with values for each measure for probabilities 0-100. Used for  plotting  
3.  *optEach*  data frame with optimum value for each measure 

A series of functions are then used to add the confidence limits of the boundaries, the commission, omission and kappa values for each optimum threshold.  These are needed to select the most appropriate threshold probability.

Finally the function *IdentifyThreshold* is used to apply a proposed rule to identify the most appropriate threshold for any particular data set. The most appropriate threshold is identified by adding a variable *Select* to *optEach* setting this to 1.  This rule needs further discussion.  (note this function uses the variable df to split data sets.  It can thus be used to a dataframe containing the results from several model runs on different sub-sets of data)

The *out* object also contains the following Values which describe the quality of the model and the prevalence of the data used

*  out$Auc  the AUC for the model
*  out$psuedo.r2  the pseudo r^2^ of the model
*  out$Prev  the prevalence of the data set

Finally the results are added to summary data frames that I use to collect the results from several runs.  For example different types.

### CW type NEA11 

```{r runModel}
#EDIT: Select the data subset
datIC.SS.NEA11 <- datIC.SS %>% 
  filter(ICtype %in% c("NEA 11")) %>%
  mutate(SuspendedMatter_mgL.1=SuspendedMatter_gL.1*1000) %>% #list options (e.g. types) to select #Geoff: CodeAggr & "type code"
  filter(!is.na(.data[[SE]])) #remove missing values
  

#EDIT countries biota EQR G/M boundary when not NEQR
IC.GM_MS1 <- 0.6 # EDIT: MS IC EQS boundary if not using normalised EQR
IC.GM_MS2 <- 0.61 # add more MS if needed (and reflect in "Functions_BLM_EQR.R" to get all hlines in Fig1d)

#EDIT: Run model and calculate measures, remember to edit line to  match dataframe name created in line above!
out <- modBLM(df=datIC.SS.NEA11 ,plt = FALSE, x=SE,y=BiotaClass,min_new.x=1,max_new.x=1,logarithm=TRUE)

# Split returned list into its constituent data frames
mod.pred <- out$mod.pred
allMeasures <- out$allMeasures

# Add additional variables
optEach <- out$optEach
optEach$lcl <- sapply(optEach$threshold,GetLCL)#lower confidence limit
optEach$ucl <- sapply(optEach$threshold,GetUCL)#upper confidence limit
optEach$commission <- sapply(optEach$threshold,GetCom)# commission value
optEach$omission <- sapply(optEach$threshold,GetOmi)# omission value
optEach$kappa <- sapply(optEach$threshold,GetKap)# kappa value
optEach$df <- out$df # name of data set used (for reference)
optEach <- optEach %>% filter(measure %in% measure_used) %>%  arrange(threshold)# filter measures and sort by ascending order of  p threshold

# run function to select the most appropriate threshold. Note in this script I include all the thresholds generated by modEva, plus the toolkit mis-match method.  This generates a longer list and it could be reduced by filtering the measures included in the optEach object that is passed to the function identifyThreshold()
optEach <- IdentifyThreshold()

#Collect the measures that are not threshold dependent.
BLMsum<- data.frame(out$df,out$pseudo.r2,out$Auc,out$Prev)
names(BLMsum) <- c("df","pseudo.r2","Auc","Prev")

# add the resulting model and boundary data to a summary file
optEach_all <- rbind(optEach_all,optEach)
BLMsum_all <- rbind(BLMsum_all,BLMsum)

# remove duplicate records, caused by running the chunk several times in error
optEach_all <- unique(optEach_all) 
BLMsum_all <- unique(BLMsum_all)
```

#### Inspect the results
scatterplot
```{r scatterplot SE vs BQE}
#EDIT: IC type SE boundaries
# IC.SE_GM_MS1lo <- 4.9
# IC.SE_GM_MS1up <- 6.5
# IC.SE_GM_MS2 <- 4

#EDIT: NEED TO MODIFY THE NEXT LINE to select appropriate data frame
df <- datIC.SS.NEA11

#scatterplot biota EQR vs SE
p0 <- GetScatterPLot0 (df=df,colName = SE,EQRVar="NEQR") 
p0 +
  geom_hline(yintercept = IC.GM_MS1,lty=2, colour="black")+
  geom_hline(yintercept = IC.GM_MS2,lty=2, colour="grey")+
  annotate(geom = "text",y=IC.GM_MS1,x=0.1,label=IC.GM_MS1,size=3,vjust=1, colour="black")+
  annotate(geom = "text",y=IC.GM_MS2,x=0.1,label=IC.GM_MS2,size=3,vjust=0, colour="grey")
#EDIT below as needed according to countries' SE GM boundaries
  # + geom_vline(xintercept = IC.SE_GM_MS1lo,colour="#F8766D")+
  # geom_vline(xintercept = IC.SE_GM_MS1up,colour="#F8766D")+
  # geom_vline(xintercept = IC.SE_GM_MS2,colour="#00BFC4")+
  #   annotate(geom = "text",x=IC.SE_GM_MS1lo,y=0.1,label=IC.SE_GM_MS1lo,size=3,hjust=1,colour="#F8766D")+
  #   annotate(geom = "text",x=IC.SE_GM_MS1up,y=0.1,label=IC.SE_GM_MS1up,size=3,hjust=1,colour="#F8766D")+
  #   annotate(geom = "text",x=IC.SE_GM_MS2,y=0.1,label=IC.SE_GM_MS2,size=3,hjust=1,colour="#00BFC4")
```

density plot
```{r biota EQS vs SE density plot}
df$BinClass <- as.factor(df$BinClass)
p0d <- GetDensityPLot0 (df=df,colName = SE,EQSVar="BinClass")
p0d
```

####  All the results

Note that in the previous chunk I am not filtering out any of the measures.  For the work on rivers I only used max kappa, omission = commission, commission = 0.1, commission = 0.2.  I noticed that in the 2nd example below the automatic selection used the toolkit method as the optimum threshold. Not sure if this is appropriate or not.

The following figure shows the measures v probability.

```{r measures thresholds}
#list the points to mark on plot
meas <- c("CCR","kappa","TKitMM","Com0.2","OmisComm","Com0.1")# these are measures selected for lines on plot a:e
 pMeas()
```

The boundary values, thresholds etc are in object optEach.  The following table shows these,the most appropriate boundary, based on the criteria I am currently using are marked as Select = 1.

```{r threshold selection}
optEach  %>% select(Select,df,Bound,lcl,ucl,threshold,measure,value,commission,omission,kappa)
```

####  The boundary selected using current criteria

The most appropriate boundary is shown here

```{r boundary selected}
optEach %>% filter(Select==1) %>% select(df,Bound,lcl,ucl,threshold,measure,commission,omission,kappa)
```


The results can be illustrated using the following 4 figures.  Note that Figs 1b and 1d depend on the direction of the pressure response.  For most SEs a high value is indicative of increased pressure. For transparency a high value is less pressure, so I have defined this as a negative response and the negResp parameter in the function call needs to be set to TRUE.  For the logistic model plot the points may  be jittered. Set jith=0.01, although I am not certain it is needed.  Control the number of decimals with dec=


```{r plot 4 graphs}
#Plot will use output from the last model run, remember to re-run the model chunk if needed
#EDIT: NEED TO MODIFY THE NEXT LINE to select appropriate data frame
df <- datIC.SS.NEA11 #select data to plot
  
# select the boundary to be plotted i.e. the appropriate measure. 
meas_u <- optEach[optEach$Select==1,"measure"]  # use  measure selected by function
#meas_u <- "Com0.2"  #To plot a different measure use this line

tsize=2  #modify the size of text

p1 <- GetFig1a(df=df,meas=meas_u,colName = SE,EQRVar="NEQR",adj=0,dec=1,negResp = FALSE,jith=0)
p2 <- GetFig1b(df=df,meas=meas_u,colName = SE,negResp = FALSE) #EDIT: "TRUE" or "FALSE"
p3 <- GetFig1c(df=df,meas=meas_u,colName= SE)
p4 <- GetFig1d(df=df,meas=meas_u,EQRVar="NEQR",colName= SE,negResp=FALSE)+
  geom_hline(yintercept = IC.GM_MS1,lty=2, colour="#F8766D")+
  geom_hline(yintercept = IC.GM_MS2,lty=2, colour="#00BFC4")+
  annotate(geom = "text",y=IC.GM_MS1,x=0.5,label=IC.GM_MS1,size=3,vjust=1, colour="#F8766D")+
  annotate(geom = "text",y=IC.GM_MS2,x=0.5,label=IC.GM_MS2,size=3,vjust=0, colour="#00BFC4")
  
grid.arrange(p1,p2,p3,p4,ncol=2,nrow=2)

```

```{r scatterplot biota EQR vs SE predicted bound}
#scatterplot biota EQR vs SE
p5 <- GetScatterPLot(df=df,meas=meas_u,colName = SE,EQRVar="NEQR") 
p5 +
  geom_hline(yintercept = IC.GM_MS1,lty=2, colour="#F8766D")+
  geom_hline(yintercept = IC.GM_MS2,lty=2, colour="#00BFC4")+
  annotate(geom = "text",y=IC.GM_MS1,x=0.1,label=IC.GM_MS1,size=3,vjust=1, colour="#F8766D")+
  annotate(geom = "text",y=IC.GM_MS2,x=0.1,label=IC.GM_MS2,size=3,vjust=0, colour="#00BFC4")
  
```



We can now repeat with another Type (change the name of the chunk if copying from above)

### TW and CW types NEA11 & NEA1-26 
To run on a different type, first select the data and then change the name of the data set when running the function (line 298 below)

```{r runModel2}
#EDIT: Select the Type-SE-BQE data 
datIC.SD.NEA <- datIC %>% 
  select (BQE,Country,WaterCategory,GIG,ICtype,Date_BQE,EQR,EQS,SecchiDepth_m)%>%
  filter (!is.na(SecchiDepth_m))%>%
  filter(BQE=="Seagrasses") %>%
  #mutate(BinClass=ifelse(NEQR>=0.6,1,0)) #use this line instead when normalised EQR
  rename(BinClass=EQS)%>%
  rename(NEQR=EQR) 

#EDIT: Select the data subset
datIC.SD.NEA <- datIC.SD.NEA %>% 
 #filter(ICtype %in% c("NEA 11", "NEA 1/26")) %>%  #list options (e.g. types) to select #Geoff: CodeAggr & "type code"
  filter(!is.na(.data[[SE]])) #remove missing values

#EDIT: countries biota EQR G/M boundary when not normalised NEQR
IC.GM_MS1 <- 0.6 # PT.TW, NL.TW 
IC.GM_MS2 <- 0.645 # FR.TW.CW add more MS if needed (and reflect in "Functions_BLM_EQR.R" to get all hlines in Fig1d)
IC.GM_MS3 <- 0.61 # IE.CW

#classify categorical classes based on IC EQR com dec 2018
datIC.SD.NEA <- datIC.SD.NEA %>%
  mutate(BinClass=ifelse(Country == "PT" & NEQR >= 0.6,1,
                        ifelse(Country=="NL" & NEQR>=0.6,1,
                               ifelse(Country=="IE" & NEQR>=0.61,1,
                                      ifelse(Country=="FR" & NEQR>=0.645,1,0)))))


#EDIT: Run model and calculate measures, remember to edit line to  match dataframe name created in line above!
# Run model and calculate measures
out <- modBLM(df=datIC.SD.NEA ,plt = FALSE, x=SE,y=BiotaClass,min_new.x=1,max_new.x=1,logarithm=TRUE)

# Split returned list into its constituent data frames
mod.pred <- out$mod.pred
allMeasures <- out$allMeasures

# Add additional variables
optEach <- out$optEach
optEach$lcl <- sapply(optEach$threshold,GetLCL)#lower confidence limit
optEach$ucl <- sapply(optEach$threshold,GetUCL)#upper confidence limit
optEach$commission <- sapply(optEach$threshold,GetCom)# commission value
optEach$omission <- sapply(optEach$threshold,GetOmi)# omission value
optEach$kappa <- sapply(optEach$threshold,GetKap)# kappa value
optEach$df <- out$df # name of data set used (for reference)
optEach <- optEach %>% filter(measure %in% measure_used)%>% arrange(threshold)# filter measures and sort by ascending order of  p threshold

optEach <- IdentifyThreshold()# run function to select the most appropriate threshold.


#Collect the measures that are not threshold dependent.
BLMsum_SoE<- data.frame(out$df,out$pseudo.r2,out$Auc,out$Prev)
names(BLMsum_SoE) <- c("df","pseudo.r2","Auc","Prev")

#Collect the measures that are not threshold dependent.
BLMsum<- data.frame(out$df,out$pseudo.r2,out$Auc,out$Prev)
names(BLMsum) <- c("df","pseudo.r2","Auc","Prev")

# add the resulting model and boundary data to a summary file
optEach_all <- rbind(optEach_all,optEach)
BLMsum_all <- rbind(BLMsum_all,BLMsum)

optEach_all <- unique(optEach_all) # remove duplicate records, caused by running the chunk several times in error
BLMsum_all <- unique(BLMsum_all)


```

#### Inspect the results

scatterplot
```{r scatterplot SE vs BQE 2}
#EDIT: IC type SE boundaries if available
# IC.SE_GM_MS1lo <- 4.9
# IC.SE_GM_MS1up <- 6.5
# IC.SE_GM_MS2 <- 4

df <- datIC.SD.NEA #EDIT subdataset name

#scatterplot biota EQR vs SE
#EDIT according to countries' SE GM boundaries
p6 <- GetScatterPLot0 (df=df,colName = SE,EQRVar="NEQR") +
  #EDIT: select from below as needed
  #if needed to plot MS biota EQR boundaries
  geom_hline(yintercept = IC.GM_MS1,lty=2, colour="purple")+ #EDIT according to no of MS
  geom_hline(yintercept = IC.GM_MS2,lty=2, colour="#F8766D")+
  geom_hline(yintercept = IC.GM_MS3,lty=2, colour="#00C094")+
  annotate(geom = "text",y=IC.GM_MS1,x=0.5,label=IC.GM_MS1,size=3,vjust=2, colour="purple")+
  annotate(geom = "text",y=IC.GM_MS2,x=0.5,label=IC.GM_MS2,size=3,vjust=-1, colour="#F8766D")+
  annotate(geom = "text",y=IC.GM_MS3,x=0.5,label=IC.GM_MS3,size=3,vjust=0, colour="#00C094")
  
  #if needed to plot MS SE boundaries where available
  # geom_vline(xintercept = IC.SE_GM_MS1lo,colour="#F8766D")+
  # geom_vline(xintercept = IC.SE_GM_MS1up,colour="#F8766D")+
  # geom_vline(xintercept = IC.SE_GM_MS2,colour="#00BFC4")+
  # annotate(geom = "text",x=IC.SE_GM_MS1lo,y=0.1,label=IC.SE_GM_MS1lo,size=3,hjust=1,colour="#F8766D")+
  # annotate(geom = "text",x=IC.SE_GM_MS1up,y=0.1,label=IC.SE_GM_MS1up,size=3,hjust=1,colour="#F8766D")+
  # annotate(geom = "text",x=IC.SE_GM_MS2,y=0.1,label=IC.SE_GM_MS2,size=3,hjust=1,colour="#00BFC4")

p7 <- ggplot(df,aes(y=NEQR, x=SecchiDepth_m, colour=ICtype))+
  geom_point()+
  theme_classic()

grid.arrange(p6,p7,ncol=2,nrow=2)
```

density plot
```{r biota EQS vs SE density plot 2}
df$BinClass <- as.factor(df$BinClass)
p6d <- GetDensityPLot0 (df=df,colName = SE,EQSVar="BinClass")
p6d
```


####  The boundary selected using current criteria

```{r measures thresholds 2}
#list the points to mark on plot
meas <- c("CCR","kappa","TKitMM","Com0.2","OmisComm","Com0.1")
 pMeas()
```

```{r threshold selection 2}
optEach  %>% select(Select,df,Bound,lcl,ucl,threshold,measure,value,commission,omission,kappa)
```

```{r  boundary selected 2}
optEach %>% filter(Select==1) %>% select(df,Bound,lcl,ucl,threshold,measure,value,omission,commission,kappa)
```

```{r plot 4 graphs 2}
#Plot will use output from the last model run, remember to re-run the model chunk if needed
#NEED TO MODIFY THE NEXT 2 LINES
df <- datIC.SD.NEA  #select data to plot
meas_u <- "OmisComm"  #select measure to use

tsize=2  #  modify the size of text
p7 <- GetFig1a(df=df,meas=meas_u,colName = SE,EQRVar="NEQR",adj=0,dec=2,negResp = TRUE,jith = 0.01)
p8 <- GetFig1b(df=df,meas=meas_u,colName = SE,negResp = TRUE)
p9 <- GetFig1c(df=df,meas=meas_u,colName= SE)
p10 <- GetFig1d(df=df,meas=meas_u,EQRVar="NEQR",colName= SE,negResp=TRUE)+
  geom_hline(yintercept = IC.GM_MS1,lty=2, colour="purple")+ #EDIT according to no of MS
  geom_hline(yintercept = IC.GM_MS2,lty=2, colour="#F8766D")+
  geom_hline(yintercept = IC.GM_MS3,lty=2, colour="#00C094")+
  annotate(geom = "text",y=IC.GM_MS1,x=2.5,label=IC.GM_MS1,size=3,vjust=2, colour="purple")+
  annotate(geom = "text",y=IC.GM_MS2,x=2.5,label=IC.GM_MS2,size=3,vjust=-1, colour="#F8766D")+
  annotate(geom = "text",y=IC.GM_MS3,x=2.5,label=IC.GM_MS3,size=3,vjust=0, colour="#00C094")
  
grid.arrange(p7,p8,p9,p10,ncol=2,nrow=2)

```

```{r scatterplot biota EQR vs SE predicted bound 2}
#scatterplot biota EQR vs SE
p11 <- GetScatterPLot(df=df,meas=meas_u,colName = SE,EQRVar="NEQR") 
p11+
  geom_hline(yintercept = IC.GM_MS1,lty=2, colour="purple")+
  geom_hline(yintercept = IC.GM_MS2,lty=2, colour="#F8766D")+
  geom_hline(yintercept = IC.GM_MS3,lty=2, colour="#00C094")+
  annotate(geom = "text",y=IC.GM_MS1,x=0.1,label=IC.GM_MS1,size=3,vjust=1, colour="purple")+
  annotate(geom = "text",y=IC.GM_MS2,x=0.1,label=IC.GM_MS2,size=3,vjust=0, colour="#F8766D")+
  annotate(geom = "text",y=IC.GM_MS3,x=0.1,label=IC.GM_MS3,size=3,vjust=0, colour="#00C094")

```


###  Plot without a fitted line
Examples showing the NEA11 data type

```{r}
# set z to any categorical variable name in the data set
pGLM_z(df=dat.IC.mac2.NEA,x=SE,z="ICtype") #EDIT z= "" as needed
```


###  Plot with fitted line

```{r}
# set z to any categorical variable name in the data set
pGLM_z_Alls(df=dat.IC.mac2.NEA,x=SE,z="ICtype") # function with #EDIT z= "" as needed
```



##  Table of combined results


To look at a set of combined results stored in optEach_all, first run the function to select the appropriate optima


```{r}
optEach_all <- IdentifyThreshold(optEach_all) # add the name of the summary data frame to the function call

optEach_all %>% filter(Select==1) %>% select(df,Select,Bound,lcl,ucl,threshold,measure,omission,commission,kappa)
```


